[Mu](http://microvm.github.io/) is a language-independent virtual machine specification, designed to be a good target to which to compile managed languages (languages with automatic storage management ("garbage collection"), threads, etc.), comparable in level to [LLVM](https://llvm.org/).  (Mu, however, aims to be lightweight and matches better to an environment with dynamic code generation and optimization.)

Meanwhile, the underlying hardware for the main memory of computers is evolving, and future computers are expected to have byte-addressable non-volatile main memory (NVM).  This is different from current dynamic ram (DRAM) in that it is non-volatile, and different from solid state disks, flash memory, etc., in that one can access and update individual bytes, as opposed to reading and writing whole blocks of data.  NVM may well partly or completely replace DRAM for main memory because NVM is physically denser, allowing more memory per card, etc.  However, its non-volatility makes it appealing for supporting "instant-on" recovery if power is lost.

Such recovery is more complicated than it might seem at first, because the contents of all the processor's registers and caches are *not* preserved. Thus the persistent state might be a bit of mess, particularly in the case where a program employs multiple concurrent threads.  Such concurrency is more and more likely in the future---individual processors are not speeding up, so the only way to improve performance is to get more "cores" working on your problems.

What is needed is to move from raw NVM to a clean language-level model of non-volatile state, called **persistence**.  Adding persistence to modern managed languages is complex---concurrent garbage collection is already arguably one of the most complex aspects of a managed language run-time, and to that we will add persistence.  All this software operates in a world that is not entirely coherent.  Different cores can see other cores actions in differing orders, and even to the extent that cache memories are coherent, main memory is not fully coherent with the cache.  One needs very carefully orchestrated updates and orderings for correct operation, and at the same time, for performance we need the *minimal* number of explicit updates and orderings.

So a good persistence run-time requires substantial integrated design and careful implementation by a team with comprehensive knowledge of the problems and solution techniques.  If each language implementation effort, new or already-existing, were to attempt this additional design and implementation effort, it would be a huge investment, and quite likely a distraction from other advances those teams might make.  The Persistent Mu project aims to provide a comprehensive language-independent persistence platform for managed languages, with semantics and capabilities most appropriate to those languages.  While the project's goals are essentially independent of Mu, Mu seems a good place to start, avoiding developing the rest of the design of a language-independent virtual machine.  Mu also has at least one prototype implementation on which we can build.